Правила Multitasking Blocks (Многозадачные блоки)

От автора: Данные правила являются одним из принципов описания и хранения css-структур. Они были выработаны в процессе довольно большой практики в вёрстке. Пробуя различные методологии, перемешивая со своими велосипедами, я в итоге пришёл к этим правилам. Это ни в коем случае не призыв "делать только так и никак больше" (методологий много и все по своему хороши), но вполне возможно, что вам тоже понравится этот набор правил, особенно для небольших и средних проектов (под которые, собственно, и затачивались данные правила).
Основной упор был сделан на то, чтобы можно было как можно легче поддерживать проект (имеется ввиду поиск нужного css-файла и стиля в нём, а так же добавление новых стилей. Это вполне актульно, например, для тех, у кого на сайте css-файлы на выходе склеиваются в один). Названия стилей нужны человекопонятными, а css-наследований выйдет не более 1-2.

Принцип MtB:  
Основная идея многозадачных блоков заключается в том, что любой HTML-блок (div, span, a итд. Далее просто "блок") может нести одну или несколько задач (о которых чуть ниже). И в зависимости от выполняемых задач формируется название класса для блока, а так же способ его хранения.  

Описание правил предлагаю рассматривать сразу на примерах. Для этого возьмём парочку рыбных макетов. Все имена классов и их описания далее будут являются примерными:  
https://dl.dropbox.com/u/31852263/sdcss/mainPage.jpg (Главная)  
https://dl.dropbox.com/u/31852263/sdcss/profilePage.jpg (Профиль)

Итак, в MtB выделяются четыре понятия (они же - задачи блока):  
1) Контекст - это блок, который является контейнером для Элементов. С помощью css-правил Контекст может слегка менять вид своих Элементов.  
На макете Главной Контекстом будет являться в первю очередь собственно сама страница главной. Также Контекстом можно назвать блок с меню и блок с фотками.  
2) Элемент - это блок, который является отображением некой сущности.  
Кнопки в меню вполне себе Элементы. Фотки тоже элементы.  
3) Разновидность - это Элемент с некоторыми изменениями.  
В меню вы можете заметить, что последняя кнопка слегка отличается от других, но тем не менее - это тоже кнопка меню (т.е. Элемент). Она лишь будет иметь Разновидность "Профильная".  
4) Статус - это некоторое состояние Элемента.  
Первый пункт меню выделен, то есть имеет статус "Текущий". Статусы как бы являются вспомогательным инструментом для выделения Элемента среди других (текущий, активный, неактивный, скрытый, расхлопнутый, итд). Сами по себе они не описываются в css-файле, но могут быть описаны в паре с Контекстом или Элементом.

Именование классов:  
1) Безусловно, имя класса у Контекста или у Элемента должно обозначать то, что они отображают.  
```css
.photos {}
.menu {}
```
2) Названия любых блоков могут содержать нижнее подчёркивание для обозначения вложенности блоков.  
Кнопки в меню можно обозначить как  
```css
.menu_button {}
```
3) Если в имени Контекста или Элемента нужно сделать какое-то уточнение, то используется camelCase.  
На макете Профиля можно уточнить, что Контекст, содержащий "достижения" является профильным.  
```css
.profileAchievs {}
```
Так же можно обозначить кнопки, которые принадлежат только менюшке, таким образом эти кнопки станут самостоятельным элементом,  
```css
.menuButton {}
```
4) Разновидности обозначаются через дефис.  
Для кнопки, ведущей на профиль у нас будет вот такой класс:  
```css
.menu_button-profile {}
```
или такой (в зависимости от того, что вы выберете)  
```css
.menuButton-profile {}
```
5) Элементы, имеющие Разновидности описываются через селекторы атрибутов.  
То есть у кнопок в меню может быть одно из следующих описаний (опять же смотря что вы выбрали между пунктов 2 и 3)  
```css
[class|="menu_button"], .menu_button {}
```
или  
```css
[class|="menuButton"], .menuButton {}
```
По этим правилам будут искаться элементы, у которых класс имеет в начале имя Элемента ("menu_button" или "menuButton"). Но проблема в том, что, если у тэга в классе будет присутствовать пробел после этого (например, добавим статус), то правило не сработает. Для этого мы добавляем просто описание класса без разновидности.  
Подробнее про селекторы атрибутов можно прочитать тут:  
http://htmlbook.ru/samcss/selektory-atributov  
6) Все статусы начинаются с нижнего подчёркивания и описываются только в паре с другими Элементами или Контекстами.  
```css
[class|="menu_button"]._cur, .menu_button._cur {}
```
Вот так описывать нельзя  
```css
._cur {}
```

Структура и хранение файлов:
1) В корневой css-папке (допустим, "ourProject/www/css/") хранятся: общие стили (например, reset.css) и описание Контекстов, которые не являются Элементами.  
В файле Контекстов описываются классы, которые описывают сам Контекст, а также вложенные в него блоки (те, что описываются через нижнее подчёркивание).  
```css
ourProject/www/css/reset.css
ourProject/www/css/common.css
ourProject/www/css/mainPage.css
ourProject/www/css/commonPage.css
```
Здесь "commonPage.css" будет описывать рутинную внутреннюю страницу (к которой так же относится и страница с Профилем)
2) Элементы хранятся в папке "elements" ("ourProject/www/css/elements/").  
Менюшка у нас хоть и является Контекстом для кнопок в меню, но тем не менее сама по себе менюшка является и Элементом, поэтому css-файл, описывающий её классы и классы вложенных блоков будет храниться по следующему пути:  
```css
ourProject/www/css/elements/menu.css
```
В нём же, кстати, будут описаны и Элементы "menu_button" и их Разновидности, так как хоть они и являются Элементами, но всё же они остаются вложенными блоками  
3) Если Элемент1 содержит другие Элементы, которые используются только в Элементе1 (то есть, по сути, Элемент1 стал Контекстом для Элемента2, Элемента3 итд), то создаётся подпапка с именем Элемента1, в которой хранятся файлы с описанием Элементов2 и Элементов3.  
Предположим, что для описания кнопок мы выбрали обозначение через camelCase, то структура файлов у нас будет примерно такая:  
```css
ourProject/www/css/elements/menu/menuButton.css
ourProject/www/css/elements/menu.css
```
В первом файле будут описан Элемент "menuButton" и его разновидности. Во втором файле будет описан только Контекст "menu" и его вложенные блоки.  
4) Разновидности Элементов описываются в файле Элемента.  
5) Изменения Элементов через Контекст описываются в файле с Контекстом.  
Допустим у нас есть файл с примерно таким содержимым  
```css
ourProject/www/css/elements/menu.css

.menu { background-color: #444444; }
/* этот блок будет содержать сами кнопки */
.menu_content {}
[class|="menu_button"], .menu_button {
    width: 120px;
    height: 34px;
}
```
Что описывает фон для меню и размеры кнопки в ней. Тогда в Контексте Главной будет вот такая запись:  
```css
ourProject/www/css/mainPage.css

.mainPage .menu { height: 140px; }
.mainPage .menu_content {
    width: 900px;
    margin: 0 auto;
}
```
Таким образом у нас на главной будет меню сверху и по центру. В Контексте Профиля (внутренней страницы) будут вот такие описания:  
```css
ourProject/www/css/commonPage.css

.commonPage .menu {
    float: left;
    width: 400px;
}
.commonPage .menu_content { margin-left: 200px; }
.commonPage [class|="menu_button"], .commonPage .menu_button { float: left; }
```
Теперь на главной у нас кнопки идут друг за другом.

Разумеется, у нас это всё сработает, если содержимое страничек будет обёрнуто в блок с классом "commonPage" или "mainPage".  
Но что делать, если оборачивать не хочется? Тогда вы просто можете изменить Элементы не через Контекст, а через Разновидность. Вот как будет это выглядеть:  
```css
ourProject/www/css/elements/menu.css
[class|="menu"], .menu { background-color: #444444; }  
.menu-top { height: 140px; }  
.menu-left {  
    float: left;  
    width: 400px;  
}

/* этот блок будет содержать сами кнопки */
.menu_content {}
.menu-top .menu_content {  
    width: 900px;  
    margin: 0 auto;  
}  
.menu-left .menu_content { margin-left: 200px; } 

[class|="menu_button"], .menu_button {  
    width: 120px;  
    height: 34px;  
}
 
.menu-top [class|="menu_button"], .menu-top .menu_button { float: left; }
```
Таким образом мы всё описали в одном файле, так как Контекст "Меню" мы меняли не через родительский Контекст, а через Разновидность, которая должна описываться в том же файле. Так как Элементы "Кнопка" у нас меняли через Контекст "Меню", то их изменения мы так же описываем в файле с Контекстом. Если же вы решил описывать кнопки как самостоятельные Элементы, то в данном случае практически ничего не поменяется, в файле не будет описания Элементов с кнопками, но изменение через Контекст всё равно останется, хоть и будет иметь теперь другой вид:  
```css
.menu-top [class|="menuButton"], .menu-top .menuButton { float: left; }
```  
Причём если вы заметили, то поиск нужного нам файла по имени класса, остаётся всё так же простым. В этом и есть одна из фишек MtB: какую бы задачу не выполнял блок, всегда и однозначно можно найти файл, в котором описываются его стили.

